import Cdclt.Term
import Cdclt.Boolean

open proof
open term
open rules
open sort

@[simp] def bimplies (x y : Bool) : Bool :=
  match x, y with
  | true, false => false
  | _,    _     => true

def beq  (x y : Bool) : Bool := x == y
def bneq (x y : Bool) : Bool := x != y

#check Bool
#check (Bool → Bool)

def Environment := Nat → (A : Type) → A
def Environment' := Nat → ∀ A : Type, A

#check Environment

def interpSort (s : sort) : Type :=
  match s with
  | arrow s₁ s₂ => (interpSort s₁) → (interpSort s₂)
  | boolSort    => Bool
  | _           => Bool

def DepInterp := Option (Σ (s : sort), Environment → interpSort s)

-- okay, lets found out how to do mutual recursion later :P
@[simp] def matchAndBuild (r₁ r₂ : DepInterp) (f : Bool → Bool → Bool) : DepInterp :=
  match r₁, r₂ with
  | some ⟨ boolSort, k₁ ⟩, some ⟨ boolSort, k₂ ⟩ =>
      some ⟨ boolSort, λ I => f (k₁ I) (k₂ I) ⟩
  | _, _ => none

def coe' {A B : Type} : (A = B) → A → B
| rfl, a => a

@[simp] noncomputable def interpTerm (t : term) : DepInterp :=
  match t with
  | term.const   n  s  => some ⟨s, λ I => I n (interpSort s) ⟩
  | term.not     t₁    => match interpTerm t₁ with
                          | some ⟨ boolSort, k ⟩ => some ⟨ boolSort, λ I => not (k I) ⟩
                          | _ => none
  | term.and     t₁ t₂ => matchAndBuild (interpTerm t₁) (interpTerm t₂) and
  | term.or      t₁ t₂ => matchAndBuild (interpTerm t₁) (interpTerm t₂) or
  | term.implies t₁ t₂ => matchAndBuild (interpTerm t₁) (interpTerm t₂) bimplies
  | term.xor     t₁ t₂ => matchAndBuild (interpTerm t₁) (interpTerm t₂) bneq
  | term.eq      t₁ t₂ => matchAndBuild (interpTerm t₁) (interpTerm t₂) beq
  | term.bot           => some ⟨ boolSort, λ _ => false ⟩
  | term.top           => some ⟨ boolSort, λ _ => true  ⟩
  | term.app     t₁ t₂ => match interpTerm t₁, interpTerm t₂ with
                          | some ⟨ arrow s₁₁ s₁₂, k₁ ⟩, some ⟨ s₂, k₂ ⟩ =>
                            if r: s₁₁ = s₂
                            then some ⟨ s₁₂, λ I => (k₁ I) (coe' (congrArg interpSort (Eq.symm r)) (k₂ I)) ⟩
                            else none
                          | _, _ => none
  | _ => none

